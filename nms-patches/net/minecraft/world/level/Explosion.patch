--- a/net/minecraft/world/level/Explosion.java
+++ b/net/minecraft/world/level/Explosion.java
@@ -39,6 +39,17 @@
 import net.minecraft.world.phys.MovingObjectPosition;
 import net.minecraft.world.phys.Vec3D;
 
+// CraftBukkit start
+import net.minecraft.world.entity.boss.EntityComplexPart;
+import net.minecraft.world.entity.boss.enderdragon.EntityEnderDragon;
+import net.minecraft.world.level.block.Blocks;
+import org.bukkit.craftbukkit.event.CraftEventFactory;
+import org.bukkit.craftbukkit.util.CraftLocation;
+import org.bukkit.event.entity.EntityExplodeEvent;
+import org.bukkit.Location;
+import org.bukkit.event.block.BlockExplodeEvent;
+// CraftBukkit end
+
 public class Explosion {
 
     private static final ExplosionDamageCalculator EXPLOSION_DAMAGE_CALCULATOR = new ExplosionDamageCalculator();
@@ -60,6 +71,10 @@
     private final SoundEffect explosionSound;
     private final ObjectArrayList<BlockPosition> toBlow;
     private final Map<EntityHuman, Vec3D> hitPlayers;
+    // CraftBukkit - add field
+    public boolean wasCanceled = false;
+    public float yield;
+    // CraftBukkit end
 
     public static DamageSource getDefaultDamageSource(World world, @Nullable Entity entity) {
         return world.damageSources().explosion(entity, getIndirectSourceEntityInternal(entity));
@@ -85,7 +100,7 @@
         this.hitPlayers = Maps.newHashMap();
         this.level = world;
         this.source = entity;
-        this.radius = f;
+        this.radius = (float) Math.max(f, 0.0); // CraftBukkit - clamp bad values
         this.x = d0;
         this.y = d1;
         this.z = d2;
@@ -96,6 +111,7 @@
         this.smallExplosionParticles = particleparam;
         this.largeExplosionParticles = particleparam1;
         this.explosionSound = soundeffect;
+        this.yield = this.blockInteraction == Explosion.Effect.DESTROY_WITH_DECAY ? 1.0F / this.radius : 1.0F; // CraftBukkit
     }
 
     private ExplosionDamageCalculator makeDamageCalculator(@Nullable Entity entity) {
@@ -146,6 +162,11 @@
     }
 
     public void explode() {
+        // CraftBukkit start
+        if (this.radius < 0.1F) {
+            return;
+        }
+        // CraftBukkit end
         this.level.gameEvent(this.source, GameEvent.EXPLODE, new Vec3D(this.x, this.y, this.z));
         Set<BlockPosition> set = Sets.newHashSet();
         boolean flag = true;
@@ -228,7 +249,37 @@
                         d9 /= d11;
                         d10 /= d11;
                         if (this.damageCalculator.shouldDamageEntity(this, entity)) {
-                            entity.hurt(this.damageSource, this.damageCalculator.getEntityDamageAmount(this, entity));
+                            // CraftBukkit start
+
+                            // Special case ender dragon only give knockback if no damage is cancelled
+                            // Thinks to note:
+                            // - Setting a velocity to a ComplexEntityPart is ignored (and therefore not needed)
+                            // - Damaging ComplexEntityPart while forward the damage to EntityEnderDragon
+                            // - Damaging EntityEnderDragon does nothing
+                            // - EntityEnderDragon hitbock always covers the other parts and is therefore always present
+                            if (entity instanceof EntityComplexPart) {
+                                continue;
+                            }
+
+                            CraftEventFactory.entityDamage = source;
+                            entity.lastDamageCancelled = false;
+
+                            if (entity instanceof EntityEnderDragon) {
+                                for (EntityComplexPart entityComplexPart : ((EntityEnderDragon) entity).subEntities) {
+                                    // Calculate damage separately for each EntityComplexPart
+                                    if (list.contains(entityComplexPart)) {
+                                        entityComplexPart.hurt(this.damageSource, this.damageCalculator.getEntityDamageAmount(this, entity));
+                                    }
+                                }
+                            } else {
+                                entity.hurt(this.damageSource, this.damageCalculator.getEntityDamageAmount(this, entity));
+                            }
+
+                            CraftEventFactory.entityDamage = null;
+                            if (entity.lastDamageCancelled) { // SPIGOT-5339, SPIGOT-6252, SPIGOT-6777: Skip entity if damage event was cancelled
+                                continue;
+                            }
+                            // CraftBukkit end
                         }
 
                         double d12 = (1.0D - d7) * (double) getSeenPercent(vec3d, entity);
@@ -247,6 +298,14 @@
                         d10 *= d13;
                         Vec3D vec3d1 = new Vec3D(d8, d9, d10);
 
+                        // CraftBukkit start - Call EntityKnockbackEvent
+                        if (entity instanceof EntityLiving) {
+                            Vec3D result = entity.getDeltaMovement().add(vec3d1);
+                            org.bukkit.event.entity.EntityKnockbackEvent event = CraftEventFactory.callEntityKnockbackEvent((org.bukkit.craftbukkit.entity.CraftLivingEntity) entity.getBukkitEntity(), source, org.bukkit.event.entity.EntityKnockbackEvent.KnockbackCause.EXPLOSION, d13, vec3d1, result.x, result.y, result.z);
+
+                            vec3d1 = (event.isCancelled()) ? Vec3D.ZERO : new Vec3D(event.getFinalKnockback().getX(), event.getFinalKnockback().getY(), event.getFinalKnockback().getZ());
+                        }
+                        // CraftBukkit end
                         entity.setDeltaMovement(entity.getDeltaMovement().add(vec3d1));
                         if (entity instanceof EntityHuman) {
                             EntityHuman entityhuman = (EntityHuman) entity;
@@ -269,7 +328,69 @@
 
         boolean flag1 = this.interactsWithBlocks();
 
-        if (flag) {
+        if (flag && false) { // CraftBukkit - All this logic need to be called later of explode events
+            ParticleParam particleparam;
+
+            if (this.radius >= 2.0F && flag1) {
+                particleparam = this.largeExplosionParticles;
+            } else {
+                particleparam = this.smallExplosionParticles;
+            }
+
+            this.level.addParticle(particleparam, this.x, this.y, this.z, 1.0D, 0.0D, 0.0D);
+        }
+
+        // CraftBukkit start - Run ExplodeEvent run in any cases
+        SystemUtils.shuffle(this.toBlow, this.level.random);
+
+        if (!flag1) {
+            this.toBlow.clear();
+        }
+
+        org.bukkit.World bworld = this.level.getWorld();
+        org.bukkit.entity.Entity explode = this.source == null ? null : this.source.getBukkitEntity();
+        Location location = new Location(bworld, this.x, this.y, this.z);
+        List<org.bukkit.block.Block> blockList = new ObjectArrayList();
+        for (int i1 = this.toBlow.size() - 1; i1 >= 0; i1--) {
+            BlockPosition cpos = this.toBlow.get(i1);
+            org.bukkit.block.Block bblock = bworld.getBlockAt(cpos.getX(), cpos.getY(), cpos.getZ());
+            if (!bblock.getType().isAir()) {
+                blockList.add(bblock);
+            }
+        }
+
+        boolean cancelled;
+        List<org.bukkit.block.Block> bukkitBlocks;
+
+        if (explode != null) {
+            EntityExplodeEvent event = new EntityExplodeEvent(explode, location, blockList, this.yield);
+            this.level.getCraftServer().getPluginManager().callEvent(event);
+            cancelled = event.isCancelled();
+            bukkitBlocks = event.blockList();
+            this.yield = event.getYield();
+        } else {
+            BlockExplodeEvent event = new BlockExplodeEvent(location.getBlock(), blockList, this.yield);
+            this.level.getCraftServer().getPluginManager().callEvent(event);
+            cancelled = event.isCancelled();
+            bukkitBlocks = event.blockList();
+            this.yield = event.getYield();
+        }
+
+        this.toBlow.clear();
+
+        for (org.bukkit.block.Block bblock : bukkitBlocks) {
+            BlockPosition coords = CraftLocation.toBlockPosition(bblock.getLocation());
+            toBlow.add(coords);
+        }
+
+        if (cancelled) {
+            this.wasCanceled = true;
+            return;
+        }
+
+        flag1 = !this.toBlow.isEmpty(); // Override this in base of blocks to destroy
+
+        if (flag) { // CraftBukkit - This logic was copied from above
             ParticleParam particleparam;
 
             if (this.radius >= 2.0F && flag1) {
@@ -281,6 +402,7 @@
             this.level.addParticle(particleparam, this.x, this.y, this.z, 1.0D, 0.0D, 0.0D);
         }
 
+        // CraftBukkit end
         if (flag1) {
             this.level.getProfiler().push("explosion_blocks");
             List<Pair<ItemStack, BlockPosition>> list = new ArrayList();
@@ -290,6 +412,17 @@
 
             while (objectlistiterator.hasNext()) {
                 BlockPosition blockposition = (BlockPosition) objectlistiterator.next();
+                // CraftBukkit start - TNTPrimeEvent
+                IBlockData iblockdata = this.level.getBlockState(blockposition);
+                Block block = iblockdata.getBlock();
+                if (block instanceof net.minecraft.world.level.block.BlockTNT) {
+                    BlockPosition sourceBlock = source == null ? BlockPosition.containing(this.x, this.y, this.z) : null;
+                    if (!CraftEventFactory.callTNTPrimeEvent(this.level, blockposition, org.bukkit.event.block.TNTPrimeEvent.PrimeCause.EXPLOSION, source, sourceBlock)) {
+                        this.level.sendBlockUpdated(blockposition, Blocks.AIR.defaultBlockState(), iblockdata, 3); // Update the block on the client
+                        continue;
+                    }
+                }
+                // CraftBukkit end
 
                 this.level.getBlockState(blockposition).onExplosionHit(this.level, blockposition, this, (itemstack, blockposition1) -> {
                     addOrAppendStack(list, itemstack, blockposition1);
@@ -314,7 +447,11 @@
                 BlockPosition blockposition1 = (BlockPosition) objectlistiterator1.next();
 
                 if (this.random.nextInt(3) == 0 && this.level.getBlockState(blockposition1).isAir() && this.level.getBlockState(blockposition1.below()).isSolidRender(this.level, blockposition1.below())) {
-                    this.level.setBlockAndUpdate(blockposition1, BlockFireAbstract.getState(this.level, blockposition1));
+                    // CraftBukkit start - Ignition by explosion
+                    if (!org.bukkit.craftbukkit.event.CraftEventFactory.callBlockIgniteEvent(this.level, blockposition1, this).isCancelled()) {
+                        this.level.setBlockAndUpdate(blockposition1, BlockFireAbstract.getState(this.level, blockposition1));
+                    }
+                    // CraftBukkit end
                 }
             }
         }
@@ -322,6 +459,7 @@
     }
 
     private static void addOrAppendStack(List<Pair<ItemStack, BlockPosition>> list, ItemStack itemstack, BlockPosition blockposition) {
+        if (itemstack.isEmpty()) return; // CraftBukkit - SPIGOT-5425
         for (int i = 0; i < list.size(); ++i) {
             Pair<ItemStack, BlockPosition> pair = (Pair) list.get(i);
             ItemStack itemstack1 = (ItemStack) pair.getFirst();
